var util = require('util');
var crypto = require('crypto');
var xtend = require('xtend');
var uuid = require('uuid').v4;
var async = require('async');
var from = require('from2');
var defaults = require('levelup-defaults');
var bytewise = require('bytewise');
var EventEmitter = require('events').EventEmitter;

function NotFoundError(message) {
    this.name = "NotFoundError";
    this.message = (message || "Not Found");
    this.notFound = true;
}
NotFoundError.prototype = Error.prototype;


function CommitDB(db, opts) {
    if(!(this instanceof CommitDB)) return new CommitDB(db, opts);
    EventEmitter.call(this);

    this.opts = xtend({
        cache: true, // you can turn off caching of heads and tail
        check: true, // check if prevs actually exist on commit
        prefix: undefined, // set a key prefix (when sharing a db, like sublevel)
        hydra: true, // TODO turn off to disallow multiple heads 
        automerge: false // TODO if set, use these opts to call db.automerge whenever there is more than one head such that there will always be only one head 
    }, opts || {});
    if(!this.opts.count) {
        this.opts.count = [];
    }

    this.tailCache = null; // cache tail
    this.headCache = null; // cache current heads;

    this.db = defaults(db, {
        keyEncoding: bytewise, 
        valueEncoding: 'json'
    });

    this.cur = null; // currently checked out commit

}

util.inherits(CommitDB, EventEmitter);

// load heads and tails from cache
CommitDB.prototype.updateCache = function(cb) {
    if(!this.opts.cache) return cb();

    this.headCache = null;
    this.tailCache = null;
    var self = this;
    this.heads(function(err, heads) {
        if(!err) return cb(err);
        self.tail(cb);
    });
}

// load heads and tails into cache
CommitDB.prototype.initCache = function(cb) {
    if(!this.opts.cache) return cb();

    if(!this.headCache && !this.tailCache) {
        return this.updateCache(cb);
    }

    if(!this.headCache) {
        return this.heads(cb);
    }

    if(!this.tailCache) {
        return this.tail(cb);
    }

    cb();
}

// return currently checked out commit id or null if none
CommitDB.prototype.current = function() {
  return this.cur;
}

// create a new commit
CommitDB.prototype.commit = function(value, opts, cb) {
    if(!cb && typeof opts === 'function') {
        cb = opts;
        opts = {};
    }
    opts = xtend({
        prev: [], // use prev as parent, rather than this.cur (can be array)
        check: this.opts.check, // check if prevs exist
        unify: false, // if true, this commit uses all current heads as prev
        stay: false, // if true then commit won't check out the current commit
        id: undefined, // override the id generated by commitdb with your own
        meta: undefined, // object of extra properties to store in meta-data
        batchFunc: this.db.batch.bind(this.db) // override the batch 
    }, opts || {});

    var self = this;
    if(opts.unify) {
        this.heads(function(err, heads) {
            if(err) return cb(err);
            delete opts.unify
            opts.prev = heads;
            self._commit(value, opts, cb);
        });
    } else {
        if(!opts.prev || !opts.prev.length) {
            if(this.cur) {
                opts.prev = [this.cur];
            }
        }
        if(typeof opts.prev === 'string') {
            opts.prev = [opts.prev];
        }
        if(!opts.prev || !opts.prev.length) {
            // sanity check
            // is user trying to add a tail to something that has a tail?
            this.tail(function(err, key) {
                if(err) return cb(err);
                if(key) return cb(new Error("Trying to add commit with no parent to a commitdb that already has a tail. Either check out an existing commit before committing or explicity specify opts.prev or set opts.unify to true"));
                this._commit(value, opts, cb);
            }.bind(this));
        } else {
            this._commit(value, opts, cb);
        }
    }
};

CommitDB.prototype._genHash = function(obj) {
    var h = crypto.createHash('sha256');
    if(!obj.prev || !obj.prev.length) {
        // seed the tail's hash with a uuid
        // to avoid having the same first-commit hash for projects
        // starting with the same data
        h.update(uuid());
    }
    h.update(JSON.stringify(obj));
    return h.digest('hex');
};

// actually commit
CommitDB.prototype._commit = function(value, opts, cb, check) {
    var self = this;

    if(!check && opts.check && opts.prev && opts.prev.length) {
        this._checkExists(opts.prev, function(err, exists, missing) {
            if(exists) return self._commit(value, opts, cb, true);
            cb(new Error("The following prev(s) do not exist: " + missing.join(', ')));
        });
        return;
    }

    var doc = {
        time: Date.now()
    };
    if(opts.prev) {
        doc.prev = opts.prev;
    } else {
        opts.prev = [];
    }

    if(typeof opts.meta === 'object') {
        var reserved = ['prev', 'time'];
        var k;
        for(k in opts.meta) {
            if(reserved.indexOf(k) > -1) continue;
            doc[k] = opts.meta[k];
        }
    }

    // is this the tail?
    var isTail = false;
    if(!opts.prev || !opts.prev.length) {
        isTail = true;
    }

    doc.value = value;
    var key = opts.id || this._genHash(doc);

    var ops = []
    // add the commit
    ops.push({type: 'put', key: ['c', key], value: doc});

    // remove the commit's prevs as heads
    var i;
    for(i=0; i < opts.prev.length; i++) {
        ops.push({type: 'del', key: ['h', opts.prev[i]]});
    }
    // add the commit as a head
    ops.push({type: 'put', key: ['h', key], value: null});

    // if this is the tail then write it
    if(isTail) {
        ops.push({type: 'put', key: ['tail'], value: key});
    }

    // if we are changing the checked out commit, remember it
    if(!opts.stay) {
        ops.push({type: 'put', key: ['lastCheckout'], value: key});
    }

    // add next-indexes (next-indexes lets you discover the children of a parent)
    for(i=0; i < opts.prev.length; i++) {
        ops.push({type: 'put', key: ['n', opts.prev[i], key], value: true});
    }

    if(this.opts.prefix) {
        for(i=0; i < ops.length; i++) {
            ops[i].key.splice(0, 0, this.opts.prefix);
        }
    }

    opts.batchFunc(ops, {}, function(err) {
        if(err) return cb(err);
        // success! update the caches
        for(i=0; i < opts.prev.length; i++) {
            delete this.headCache[opts.prev[i]];
        } 
        if(!this.headCache) this.headCache = {};
        this.headCache[key] = true;
        if(!opts.stay) {
            this.cur = key;
        }
        if(isTail) {
            this.tailCache = key;
        }
        cb(null, key, doc);
    }.bind(this));
};

CommitDB.prototype.merge = function(value, prevs, cb) {
    var opts = {};
    if(typeof prevs === 'function' || !prevs || !prevs.length) {
        cb = prevs;
        opts.unify = true;
    } else {
        opts.prev = prev;
    }
    this.commit(value, opts, cb);
};

// automatically merge prevs (or all heads) using specified strategy
CommitDB.prototype.automerge = function(prevs, opts, cb) {
  opts = xtend({
    // Strategies:
    // 'merge' does a deep extend of prev objects starting from highest priority
    // 'keep' keeps the highest-priority prev value
    // or specify a function that will get an array of the prev docs 
    // and calls back with the value to use like so:
    //   strategy: function(err, prevDocs, cb) {cb(null, prevDocs[0].value)}
    strategy: 'merge', 
    priority: 'time', // 'time' to prioritize newest first or a comparator function
    reverse: false // reverse priority
  }, opts || {});
    
  // ToDo
  throw new Error("unimplemented");
};

// Revert to an old commit
// This just creates a new commit with the value of the old commit
// and marks the new commit as a revert from the old commit
// by setting .revertedFrom to the id of the previous commit
// takes the same opts as .commit
CommitDB.prototype.revert = function(toCommit, opts, cb) {
    if(typeof opts === 'function') {
        cb = opts;
        opts = {};
    }
    opts.meta = opts.meta || {};
    opts.meta.revertedFrom = toCommit;

    this._get(toCommit, function(err, doc) {
        if(err) return cb(err);
        this.commit(doc.value, opts, cb);
    });
}


// re-used logic for check functions
CommitDB.prototype._baseCheck = function(commit, cb, callback) {
    if(typeof commit === 'function') {
        cb = commit;
        commit = null;
    }
    commit = commit || this.cur;
    if(!commit) {
        var err = new Error("You must specify or check out a commit");
        if(cb) return cb(err);
        throw err;
    }
    return callback(commit, cb);
}

// is this commit a merge?
// (does it have multiple prevs)
CommitDB.prototype.isMerge = function(commit, cb) {
    return this._baseCheck(commit, cb, this._isMerge);
}

CommitDB.prototype._isMerge = function(commit, cb) {
    function isObjMerge(obj) {
        return (commit.prev && commit.prev.length > 1) ? true : false;
    }

    if(typeof commit === 'object') {
        if(cb) {
            return process.nextTick(function() {
                cb(null, isObjMerge(commit));
            });
        }
        return isObjMerge(commit);
    }
    if(!cb) throw new Error("You must use a commit object, not a commit id, as argument if you plan to call this function synchronously");

    this._get(commit, function(err, obj) {
        if(err) return cb(err);
        
        cb(null, isObjMerge(obj));
    });
}

// is this a revert from a previous commit?
CommitDB.prototype.isRevert = function(commit, cb) {
    return this._baseCheck(commit, cb, this._isFork);
}

CommitDB.prototype._isRevert = function(commit, cb) {
    var ret;
    if(typeof commit === 'object') {
        ret = commit.revertedFrom || false;
        if(cb) return process.nextTick(function() {cb(null, ret)});
        return ret;
    }
    if(!cb) throw new Error("You must use a commit object, not a commit id, as argument if you plan to call this function synchronously");
    
    this._get(commit, function(err, obj) {
        if(err) return cb(err);

        cb(null, obj.revertedFrom || false);
    });
}

// is this commit a fork?
// (does it have multiple nexts)
CommitDB.prototype.isFork = function(commit, cb) {
    return this._baseCheck(commit, cb, this._isFork);
}


CommitDB.prototype._isFork = function(commit, cb) {
    if(typeof commit === 'object') {
        if(!commit.id) return cb(new Error("commit object has no .id"));
        commit = commit.id;
    }

    this._nextIDs(commit, function(err, ids) {
        if(err) return cb(err);
        
        if(ids && ids.length > 1) {
            cb(null, true);
        } else {
            cb(null, false);
        }
    });
}

// is this commit a head?
CommitDB.prototype.isHead = function(commit, cb) {
    return this._baseCheck(commit, cb, this._isHead);
}

CommitDB.prototype._isHead = function(commit, cb) {

    if(typeof commit === 'object') {
        if(!commit.id) return cb(new Error("commit object has no .id"));
        commit = commit.id;
    }
    if(this.opts.cache && this.headCache) {
        var ret = false;
        if(this.headCache[commit]) {
            ret = true;
        }
        if(cb) return process.nextTick(function() {cb(null, ret)});
        return ret;
    }
    if(!cb) throw new Error("Cache must be enabled and initialized in order to call this function synchronously");

    this._getHead(commit, function(err, commit) {
        if(err) return cb(err);
        
        if(commit) {
            cb(null, true);
        } else {
            cb(null, false);            
        }
    });
}

// is this commit the tail?
// (does it not have any prevs?)
// this function can be used as sync if you pass a commit object
// rather than a commit id
CommitDB.prototype.isTail = function(commit, cb) {
    if(typeof commit === 'function') {
        cb = commit;
        commit = null;
    }
    commit = commit || this.cur;
    if(!commit) {
        var err = new Error("You must either check out a commit or supply a commit id");
        if(cb) return cb(err);
        throw err;
    }
    return this._isTail(commit, cb);
}

CommitDB.prototype._isTail = function(commit, cb) {
    function isObjTail(obj) {
        return (!commit.prev || !commit.prev.length) ? true : false;
    }

    if(typeof commit === 'string') {
        if(this.opts.cache && this.tailCache) {
            var ret = (this.tailCache === this.commit);
            if(cb) return process.nextTick(function() {cb(null, ret)});
            return ret;
        }
        if(!cb) throw new Error("You must use a commit object, not a commit id, as argument if you plan to call this function synchronously");
        this._get(commit, function(err, commit) {
            if(err) return cb(err);

            cb(null, isObjTail(commit));

        });
    } else {
        var ret = isObjTail(commit);
        if(cb) {
            process.nextTick(function() {cb(null, ret)});
        } else {
            return ret;
        }
    }
}


// delete a commit
CommitDB.prototype.del = function(key, opts) {
    if(typeof key === 'object') {
        opts = key;
        key = null;
    }
    opts = xtend({
        recursive: false // delete a non-head commit and all its children
    }, opts || {});

    throw new Error("unimplemented");
    // ToDo implement

    // note: only allow deletion of head commits
};

// get a commit
CommitDB.prototype.get = function(id, cb) {
    if(typeof id === 'function') {
        cb = id;
        id = this.cur;
    }
    if(!id) return cb(new Error("Either specify or check out a commit"));
    this._get(id, cb);
};

CommitDB.prototype._key = function(key) {
    if(this.opts.prefix) key.splice(0, 0, this.opts.prefix);
    return key;
};

CommitDB.prototype._get = function(id, cb) {

    this.db.get(this._key(['c', id]), function(err, obj) {
        if(err) {
            if(err.notFound) return cb(new NotFoundError("No such commit: " + id));
            return cb(err);
        }
        if(!obj) {
            return cb(new Error("Encountered invalid commit: " + id));
        }
        obj.id = id;
        cb(null, obj);
    });
};

// check out a commit
CommitDB.prototype.checkout = function(commit, opts, cb) {
    if(typeof commit === 'function') {
        cb = commit;
        opts = {};
        commit = null;
    } else if(typeof opts === 'function') {
        cb = opts;
        opts = null;
    }
    if(commit && typeof commit === 'object') {
        commit = commit.id;
    }
    var self = this;
    if(this.opts.cache) {
        this.initCache(function(err) {
            if(err) return cb(err);
            self._checkout(commit, opts, cb);
        });
    } else {
        self._checkout(commit, opts, cb);
    }
}

CommitDB.prototype._checkout = function(id, opts, cb) {
    var self = this;
    opts = xtend({
        fetch: true, // check if commit exists and return commit
        remember: true // remember most recently checked out commit
    }, opts || {});

    cb = cb || function(){};

    // if no id supplied, attempt to fetch saved checkout
    if(!id) {
        this._getLastCheckout(function(err, id) {
            if(err) return cb(err);
            if(!id) return cb(null, null, null);
            opts.remember = false;
            self._checkout(id, opts, cb);
        });
        return;
    }

    function finalize(id, data, cb) {
        self.cur = id;
        if(opts.remember) {
            self._saveLastCheckout(id, function(err) {
                if(err) return cb(err);
                cb(null, id, data);
            });
        } else {
            cb(null, id, data);
        }
    }

    if(!opts.fetch) {
        return finalize(id, null, cb);
    }
    this._get(id, function(err, data) {
        if(err) return cb(err);
        finalize(id, data, cb);
    });
};

// save a commit as being the last checked out commit
// so the same commit can be checked out next time the db is loaded
CommitDB.prototype._saveLastCheckout = function(id, cb) {
    this.db.put(this._key(['lastCheckout']), id, cb);
};

// retrieve commit saved by _saveLastCheckout
CommitDB.prototype._getLastCheckout = function(cb) {
    this.db.get(this._key(['lastCheckout']), function(err, id) {
        if(err) {
            if(err.notFound) return cb(null, null);
            return cb(err);
        }
        return cb(null, id);
    });
};

// get prev commit(s) (from current checkout or specified commit)
CommitDB.prototype.prev = function(key, opts, cb) {
    if(typeof key === 'function') {
        cb = key;
        key = this.cur;
        opts = {};
    } else if(typeof opts === 'function') {
        cb = opts;
        if(typeof key === 'object' && !key.prev) {
            opts = key;
            key = this.cur;
        } else {
          opts = {};
        }
    };
    opts = xtend({
        idOnly: false // only get prev ids, not full objects
    }, opts || {});

    if(!key) return cb(new Error("Either specify or check out a commit"));
    this._prev(key, opts, cb);
};

CommitDB.prototype._prev = function(commit, opts, cb) {
    var self = this;
    if(typeof commit === 'object') {
        this._getArray(commit.prev || [], opts, cb);
    } else {
      this._get(id, function(err, obj) {
          if(err) return cb(err);
          self._getArray(commit.prev || [], opts, cb);          
      });
    }
};

CommitDB.prototype._checkExists = function(ids, cb) {
    var missing = [];
    var self = this;
    async.eachSeries(ids, function(id, cb) {
        self._get(id, function(err, obj) {
            if(err) {
                if(!err.notFound) return cb(err);
                missing.push(id);
            }
            cb();
        });
    }, function(err) {
        if(err) return cb(err);
        if(missing.length === 0) {
            cb(null, true, missing);
        } else {
            cb(null, false, missing);
        }
    });
};

CommitDB.prototype._getArray = function(ids, opts, cb) {
    var objs = [];
    var self = this;
    async.eachSeries(ids, function(id, cb) {
        self._get(id, function(err, obj) {
            if(err) return cb(err);
            if(opts.idOnly) {
                objs.push(id);
            } else { 
                obj.id = id;
                objs.push(obj);
            }
            cb();
        });
    }, function(err) {
        if(err) return cb(err);
        cb(null, objs);
    });
}

// get next commit(s) (from current checkout or specified commit)
CommitDB.prototype.next = function(key, opts, cb) {
    if(typeof key === 'function') {
        cb = key;
        key = this.cur;
    } else if(typeof opts === 'function') {
        cb = opts;
        opts = {};
    }
    opts = xtend({
        idOnly: false // only get next ids, not full objects
    }, opts || {});
    if(!key) return cb(new Error("Either specify or check out a commit"));
    if(opts.idOnly) {
        this._nextIDs(key, cb);
    } else {
        this._next(key, cb);
    }
};

CommitDB.prototype._next = function(id, cb) {
    var self = this;
    this._nextIDs(id, function(err, nextIDs) {
        if(err) return cb(err);
        var commits = [];
        async.eachSeries(nextIDs, function(nextID) {
            self.db.get(self._key(nextID), function(err, doc) {
                if(err) return cb(err);
                doc.id = id;
                commits.push(doc);
            });
        }, function(err) {
            if(err) return cb(err);
            cb(null, commits);
        });
    });
};


// get IDs of next commit(s)
CommitDB.prototype._nextIDs = function(id, cb) {

    var s = this.db.createKeyStream({
        gt: this._key(['n', id, '']),
        lt: this._key(['n', id, '\uffff'])
    });

    var self = this;
    var ids = [];
    var cbCalled = 0;

    s.on('data', function(data) {
        ids.push(data[data.length-1]);
    });
           
    s.on('end', function() {
        if(cbCalled++) return;
        cb(null, ids);
    });

    s.on('error', function(err) {
        if(cbCalled++) return;
        cb(err);
    });
};

// retrieve stored counts
CommitDB.prototype.getCount = function(id, cb) {

};

// stream of previous commits
CommitDB.prototype.prevStream = function(commit, opts) {
    if(typeof commit === 'object') {
        opts = commit;
        commit = null;
    }

    commit = commit || this.cur;
    return this._prevStream(commit, opts);
};

CommitDB.prototype._prevStream = function(commit, opts) {
    opts = xtend({
        preventDoubles: true, // prevent the same key from being streamed twice
        idOnly: false, // only output IDs of commits
        skipCurrent: true // don't output the current commit (start with the prev)
    }, opts || {});

    var keys = {}; // already processed keys
    var queue = []
    if(commit) {
        queue.push(commit);
    }

    var i;
    var self = this;
    function getPrevs(c, cb) {
        self._get(c, function(err, data) {
            if(err) return cb(err);
            if(opts.preventDoubles) {
                for(i=0; i < data.prev.length; i++) {
                    if(keys[data.prev[i]]) continue;
                    keys[data.prev[i]] = true;
                    queue.push(data.prev[i]);
                }
            } else {
                queue = queue.concat(data.prev);
            }
            // skip the current commit
            if(opts.skipCurrent && c === commit) {
                if(queue.length) {
                    getPrevs(queue.shift(), cb);
                } else {
                    cb(null, null);
                }
                return;
            }
            data.id = c;
            cb(null, data, c);
        });
    }

    return from.obj(function(size, next) {
        if(queue.length) {
            getPrevs(queue.shift(), function(err, doc, c) {
                if(err) return next(err);
                if(doc === null) return next(null, null);
                if(opts.idOnly) {
                    next(null, c);
                } else {
                    next(null, doc);
                }
            });
        } else {
            next(null, null);
        }
    });
}

// stream of next commits
CommitDB.prototype.nextStream = function(commit, opts) {
    if(typeof commit === 'object') {
        opts = commit;
        commit = null;
    }

    commit = commit || this.cur;
    return this._nextStream(commit, opts);
}

CommitDB.prototype._nextStream = function(commit, opts) {
    opts = xtend({
        preventDoubles: true, // prevent the same key from being streamed twice
        idOnly: false, // only output IDs of commits
        skipCurrent: true // don't output the current commit (start with the next)
    }, opts || {});

    var keys = {}; // already processed keys
    var queue = [];
    if(commit) {
        queue.push(commit);
    }
    var first = true;

    var i;
    var self = this;

    function getNext(c, cb) {
        self._nextIDs(c, function(err, nextIDs) {

            if(err) return cb(err);
            if(opts.preventDoubles) {
                for(i=0; i < nextIDs.length; i++) {
                    if(keys[nextIDs[i]]) continue;
                    keys[nextIDs[i]] = true;
                    queue.push(nextIDs[i]);
                }
            } else {
                queue = queue.concat(nextIDs);
            }

            if(first && opts.skipCurrent) {
                if(queue.length) {
                    getNext(queue.shift(), cb);
                } else {
                    cb(null, null);
                }
            } else {
                if(opts.idOnly) {
                    cb(null, c);
                } else {
                    self._get(c, function(err, doc) {
                        if(err) return cb(err);
                        cb(null, doc);
                    });
                }                
            }
            first = false;
        });
        
    }

    return from.obj(function(size, next) {
        if(queue.length) {
            getNext(queue.shift(), function(err, doc) {
                if(err) return next(err, null);
                if(doc === null) return next(null, null);
                next(null, doc);
            });
        } else {
            next(null, null);
        }
    });
}

// stream of heads
CommitDB.prototype.headStream = function() {
    return this.db.createReadStream({
        gt: this._key(['h']),
        lt: this._key(['h\uffff'])
    });
};

// get a head
CommitDB.prototype._getHead = function(id, cb) {
    this.db.get(this._key(['h', id]), function(err, obj) {
        if(err) {
            if(err.notFound) return cb(null, null);
            return cb(err);
        }
        obj.id = id;
        cb(null, obj);
    });
};

// get array of current heads
CommitDB.prototype.heads = function(cb) {
    if(this.headCache && this.opts.cache) {
        process.nextTick(function() {
            cb(null, Object.keys(this.headCache));
        }.bind(this));
    } else {
        this.headCache = [];
        var cbCalled = 0;
        var s = this.headStream();
        var key;
        s.on('data', function(data) {
            key = data.key[data.key.length - 1];
            this.headCache[key] = true;
        }.bind(this));
           
        s.on('end', function() {
            if(cbCalled++) return;
            cb(null, Object.keys(this.headCache));
        }.bind(this));

        s.on('error', function(err) {
            if(cbCalled++) return;
            cb(err);
        });
    }
}

// get the tail
CommitDB.prototype.tail = function(cb) {
    if(this.tailCache && this.opts.cache) {
        if(cb) {
            process.nextTick(function() {
                cb(null, this.tailCache);
            }.bind(this));
        } else {
            return this.tailCache;
        }
    } else {
        this.db.get(this._key(['tail']), function(err, data) {
            if(err) {
                if(!err.notFound) {
                    return cb(err);
                } else {
                    return cb(null, null);
                }
            }
            cb(null, data);
        });
    }
}

module.exports = CommitDB;
